# 理论

## 左递归的消除
如果一个文法中有一个非终结符号A使得对某个串𝛂存在一个推导A => A𝛂, 那么这个文法就是左递归的。

例子, 将左递归的式子替换为非左递归的

```
A -> A𝛂 | 𝞫

=> 

A  -> 𝞫A'
A' -> 𝛂A' | ℇ
```


## 提取左公因子

提取左公因子是一种文法转换文法， 它可以产生适用于预测分析技术或自顶向下分析技术的文法。

例子

```

A -> 𝛂𝞫1 | 𝛂𝞫2

=> 

A -> 𝛂A'

A' -> 𝞫1 | 𝞫2
```


## First 和 Follow

自顶向下和自底向上语法分析器的构造可以使用和文法G相关的两个函数FIRST和FOLLOW来实现.

FIRST(a)被定义为可从a推导得到的串的首符号的集合， 其中a是任意的文法符合串。 如果 a => ℇ, 那么ℇ也在FIRST(a)中。 
比如
```
S => ab 
FIRST(S) = a
``` 

对于非终结符号A, FOLLOW(A)被定义为可能在某些句型中紧跟在A右边的终结符号的集合。 

比如
```
S => aAaB  

FOLLOW(A) = a 
```

另外如果A是某些句型的最右符号, 那么$也在FOLLOW(A)中, $是一个特殊的结束标记符号。

**计算各个符号X的FIRST(X)时， 不断应用下列规则， 直到再没有新的终结符号或ℇ可以被加入到任何FIRST集合中为止:**
1. 如果X是一个终结符号， 那么FIRST(X) = X 
2. 如果X是一个非终结符号， 且X->Y1Y2...Yk是一个产生式, 其中K >= 1, 那么如果对于某个i, a在FIRST(Yi)中且ℇ 在所有的FIRST(Y1) ... FIRST(yi - 1)中， 那么FIRST(X) = a 
3. 如果X -> ℇ 是一个产生式, 那么将ℇ加入到FIRST(X)中.

**计算所有非终结符号A的FOLLOW(A)集合时候， 不断应用下面的规则， 知道再没有新的终结符号可以被加入到任意FOLLOW集合中为止**
1. 将$放到FOLLOW(S)中， 其中S是开始符号, 而$是输入右端的结束标记.
2. 如果存在一个产生式A -> 𝞪B𝞫, 那么FIRST(𝞫)中除ℇ之外的所有符号都在FOLLOW(B)中。
3. 如果存在一个产生式A -> 𝞪B, 或存在产生式A -> 𝞪B𝞫 且FIRST(𝞫)包含ℇ, 那么FOLLOW(A)中所有符号都在FOLLOW(B)中。


## LL(1)
对于称为LL(1)的文法， 我们可以构造出预测分析器, 既不需要回溯的递归下降语法分析器。 第一个L表示从左到右扫描输入, 第二个L表示产生最左推导, "1" 表示每一步中只需要向前看一个输入符号来决定语法分析动作。


一个文法G是LL(1)的， 当切仅当G的任意两个不同的产生式A -> 𝞪 | 𝞫满足下面的条件:

1. 不存在终结符号a使得𝞪和𝞫都能够推导出a开头的串
2. 𝞪和𝞫最多只有一个可以推导出空串
3. 如果𝞫 => ℇ, 那么𝞪不能推导出任何以FOLLOW(A)中某个终结符号开头的串。 类似地, 如果𝞪 => ℇ， 那么𝞫不能推导出任何以FOLLOW(A)中某个终结符号开头的串

## 构造一个预测分析表
对于文法G的每个产生式A -> 𝞪， 进行如下处理
1. 对于FIRST(𝞪)中的每个终结符号𝞪， 将A->𝞪加入到M[A, 𝞪]中。
2. 如果ℇ在FIRST(𝞪)中， 那么对于FOLLOW(A)中的每个终结符号b, 将A -> 𝞪加入到M[A, b]中。 如果ℇ 在FIRST(𝞪)中， 且$在FOLLOW(A)中， 也将A->𝞪加入到[A, $]中。
3. 在完成上面的操作之后， 如果M[A, 𝞪]中没有产生式， 那么将M[A, 𝞪]设置为空.

## LR语法
LR语法分析是表格驱动, 原因如下：

- 对于几乎所有的程序设计语言构造， 只要能够写出该构造的上下文无关文法， 就能够构造出识别该构造的LR语法分析器。
- LR语法分析方法是已知的最通用的无回溯 - 规约分析技术
- 一个LR语法分析器可以在输入进行从左到右扫描时尽可能地检测到错误.
- 


